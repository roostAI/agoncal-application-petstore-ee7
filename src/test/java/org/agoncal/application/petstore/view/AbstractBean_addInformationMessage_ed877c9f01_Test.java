// ********RoostGPT********
/*
Test generated by RoostGPT for test java-test using AI Type Azure Open AI and AI Model roost-gpt4-32k

ROOST_METHOD_HASH=addInformationMessage_2475bafc19
ROOST_METHOD_SIG_HASH=addInformationMessage_ed877c9f01

================================VULNERABILITIES================================
Vulnerability: Cross-Site Scripting (XSS) or CWE-79
Issue: If user-controlled data is directly passed to `addInformationMessage()`, it could lead to an XSS attack. In an XSS attack, the attacker crafts a malicious script that is executed in the user's browser.
Solution: Ensure that any user-supplied input passed to `addInformationMessage()` is properly sanitized or encoded to prevent XSS vulnerabilities. Leverage available Java EE methods for escaping special characters.

Vulnerability: Injection Attacks or CWE-74
Issue: From the code snippet, `args` seems to have the chance to carry user-supplied input, and if it's directly inserted into the message, it might result in a sort of injection attack.
Solution: Always validate and sanitize user-supplied input. Ensure to use parameterized APIs or use a safe API which avoids the utilization of the interpreter entirely.

================================================================================
1. Null message input: Write a test case to verify if the function handles null message input correctly without failing or causing an exception.
   
2. Single argument message: Write a test scenario to confirm if the function adds a message with a single argument properly into the FacesContext.

3. Multiple arguments message: Write a test scenario to verify if the function adds a message with multiple arguments correctly into the FacesContext.

4. Argument exceeding message placeholders: Insert a message to the function having more arguments than placeholders in the message to test how the function handles it.

5. Argument less than message placeholders: Feed a message with arguments less than the placeholders in the message to check how the function will react.

6. Valid Locale Test: Enter a valid locale for the input parameter and check if the function produces an internationalized message based on the locale.

7. Invalid Locale Test: Provide an invalid locale as Input and test how the function behaves.

8. Verify FacesMessages Severity: Check whether the severity of FacesMessage added in FacesContext is FacesMessage.SEVERITY_INFO.

9. Null Context Instance: Test how the function behaves when FacesContext.getCurrentInstance() returns null.

10. Validate return: Ensure that once the function has been run, the returned FacesMessage has been properly added to the FacesContext instance.

11. Check Multiple Calls: Ensure that when multiple calls are made to the function, each message is saved to the context correctly.

12. Large messages test: Write a test scenario where you test the function's ability to handle large messages.

13. Test the function with expected integer and String arguments: Ensure that it correctly formats the arguments into the final message.

14. Exception Handling: Verify that the method handles exceptions correctly, if any of the inputs cause an exception to be thrown. In particular, verify the exception handling of MessageFormat and ResourceBundle when given bad inputs. 

15. Null Arguments: Validate the function's behavior when null arguments are passed.
*/

// ********RoostGPT********
package org.agoncal.application.petstore.view;

import org.agoncal.application.petstore.util.Loggable;
import org.junit.Before;
import org.junit.Test;
import javax.faces.application.FacesMessage;
import javax.faces.context.FacesContext;
import javax.inject.Inject;
import java.text.MessageFormat;
import java.util.Locale;
import java.util.Map;
import java.util.ResourceBundle;

import static org.mockito.Mockito.*;

import java.util.logging.Logger;

import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

public class AbstractBeanTest {

    public class AbstractBeanUnderTest {
        @Inject
        @Loggable
        private transient Logger logger;

        public String getMessage(FacesContext facesContext, String msgKey, Object... args){
            Locale locale = facesContext.getViewRoot().getLocale();
            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
            ResourceBundle bundle = ResourceBundle.getBundle("Messages", locale, classLoader);
            String msgValue = bundle.getString(msgKey);
            return MessageFormat.format(msgValue, args);
        }

        public void addInformationMessage(String message, Object... args){
            FacesContext context = FacesContext.getCurrentInstance();
            context.addMessage(null, new FacesMessage(FacesMessage.SEVERITY_INFO, getMessage(context, message, args), null));
        }
    }

    AbstractBeanUnderTest abstractBeanUnderTest;

    @Mock
    FacesContext facesContextMock;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        abstractBeanUnderTest = new AbstractBeanUnderTest();
    }

    @Test
    public void testAddInformationMessage() {
        Object[] args = {"arg1"};
        abstractBeanUnderTest.addInformationMessage("test_message {0}", args);

        verify(facesContextMock, times(1))
        .addMessage(isNull(), argThat(fm -> fm.getSeverity() == FacesMessage.SEVERITY_INFO &&
            fm.getSummary().contains(args[0].toString())));
    }
}
