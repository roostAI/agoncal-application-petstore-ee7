// Test generated by RoostGPT for test java-test using AI Type Azure Open AI and AI Model roost-gpt4-32k

/*
1. Test Scenario: 
Test where name is null.
Expected Result: 
This should return 0 as per the hashCode() contract in Java.

2. Test Scenario:
Test where name is an empty string.
Expected Result:
Return the hashCode of an empty string, as per Java's String hashCode calculation.

3. Test Scenario:
Test for different names. This is to check that distinct names will produce distinct hash codes.
Expected Result: 
Hash codes should be different for different names.

4. Test Scenario: 
Test for the same name twice. To ensure that hashCode is consistence for the same data.
Expected Result: 
Hash codes should be the same when checked twice for consistency.

5. Test Scenario: 
Test for a very large name. To test if the function performs well on large inputs.
Expected Result: 
The function should return a valid hash code which confirms to the string hashCode calculation in Java, even if the name is very large.

6. Test Scenario: 
Test where name contains special characters or numeric values.
Expected Result: 
Function should still return a value without error, it should handle names with characters or numbers appropriately.

7. Test Scenario: 
Test where name contains spaces.
Expected Result: 
The function should return a hash code as it should treat a space as a valid character in a string.
*/
package org.agoncal.application.petstore.model;

import org.junit.Assert;
import org.junit.Test;

public class Category_hashCode_5a2657087a_Test {

    @Test
    public void whenNameIsNull_returnZero() {
        Category testCategory = new Category();
        testCategory.setName(null);
        Assert.assertEquals(0, testCategory.hashCode());
    }

    @Test
    public void whenNameIsEmpty_returnHashCodeOfEmptyString() {
        Category testCategory = new Category();
        testCategory.setName("");
        Assert.assertEquals("".hashCode(), testCategory.hashCode());
    }

    @Test
    public void whenNameValueChanges_returnDistinctHashCodes() {
        Category testCategory1 = new Category();
        testCategory1.setName("sampleName1");

        Category testCategory2 = new Category();
        testCategory2.setName("sampleName2");

        Assert.assertNotEquals(testCategory1.hashCode(), testCategory2.hashCode());
    }

    @Test
    public void whenNameIsSameTwoTimes_checkHashCodeForConsistency() {
        Category testCategory = new Category();
        testCategory.setName("sampleName");

        int hashCode1 = testCategory.hashCode();
        int hashCode2 = testCategory.hashCode();

        Assert.assertEquals(hashCode1, hashCode2);
    }

    @Test
    public void whenNameIsVeryLarge_returnValidHashCode() {
        StringBuilder largeName = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            largeName.append("a");
        }

        Category testCategory = new Category();
        testCategory.setName(largeName.toString());
        Assert.assertEquals(largeName.toString().hashCode(), testCategory.hashCode());
    }

    @Test
    public void whenNameHasSpecialCharactersOrNumbers_returnValidHashCode() {
        Category testCategory = new Category();
        testCategory.setName("sp3ci@lCh@r");
        Assert.assertEquals("sp3ci@lCh@r".hashCode(), testCategory.hashCode());
    }

    @Test
    public void whenNameContainsSpaces_returnValidHashCode() {
        Category testCategory = new Category();
        testCategory.setName("contains spaces");
        Assert.assertEquals("contains spaces".hashCode(), testCategory.hashCode());
    }
}
